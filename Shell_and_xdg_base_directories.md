# Подготовка

Перед началом работы, установите необходимые пакеты:
```bash
pacman -S zsh fzf zoxide wl-clipboard opendoas
```

# Doas

Настроим эскалацию привилегий. Конечно, существует sudo, но с ним есть проблемы:

- Слишком большое количество фич, аудита, встроенный email клиент Мы настраиваем личное устройство, нам не нужно ничего кроме эскалации привилегий.
- Из-за того, что проект очень большой, в нем за все время накопился довольной большой [список уязвимостей](https://www.cve.org/CVERecord/SearchResults?query=sudo). doas не так популярен, проект меньше, взломать пытаются сильно реже.
- sudo игнорирует SIGINT (Ctrl+C), отправленный в момент проверки пароля. Таким образом, если мы ввели sudo случайно, или же хотим отменить команду, придётся подождать.

Конфигурационный файл для doas находится по пути `/etc/doas.conf`

Минимальный рабочий конфиг (замените your_username):
```
permit persist setenv { LANG=$LANG } your_username
permit nopass setenv { LANG=$LANG } root
```

Для пользователя мы разрешаем выполнять команды от имени любого пользователя. Переменную LANG текущего пользователя "пробрасываем" в env пользователя, от которого выполняем команду. persist позволяет какое-то время **в рамках того же процесса zsh** не спрашивать пароль (чтобы не вводить его если надо несколько команд подряд запустить)
Для рута разрешаем всё то же самое, только без запроса пароля, а следовательно, и без persist.
Дополнительно смотрите `man doas.conf`

Использование аналогично sudo:
```bash
doas cmd # выполнить команду от рута
doas -u anotheruser cmd # выполнить команду от другого юзера
doas -s # провалиться в shell рута
doas -u anotheruser -s # провалиться в вshell другого пользователя
```

# Смена shell по умолчанию

Для начала, переключите shell по-умолчанию для текущего пользователя на zsh:
```bash
which zsh # чтобы посмотреть путь
doas chsh your_username # команда спросит полный путь к шеллу, введите то что вывела команда which
```

Zsh использует 2 конфигурационных файла: `~/.zprofile` и `~/.zshrc`. В первом мы можем объявить переменные, объявляемые **при логине пользователя** в систему, во втором - **при каждом запуске терминала**. 

# XDG Base Directories

Домашняя директория пользователей не предназначена для того, чтобы в ней хранить конфигурационные файлы прикладного и/или системного ПО. Точнее, хранить конфиги можно и нужно в ней, но не в самом корне. В корне должны находиться такие директории, как Documents, Download, Music, Videos и другие директории, которые пользователь будет создавать/удалять/изменять/наполнять файлами самостоятельно.

Существует спецификация, которая называется [XDG Base Directory Specification](https://specifications.freedesktop.org/basedir/latest/), созданная с целью определить, где должны находиться данные пользовательских приложений. В ней задаётся несколько директорий для хранения кеша, конфигурации, данных и состояния.

| Переменная окружения | Рекомендуемое значение | Описание                                                                                                                                                                                                                                                     |
| -------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `XDG_CONFIG_HOME`    | `$HOME/.config`        | Файлы конфигурации приложений, аналог `/etc` для пользователя                                                                                                                                                                                                |
| `XDG_DATA_HOME`      | `$HOME/.local/share`   | Данные приложений (шрифты, загружаемые приложением ресурсы). Аналог `/usr/share`                                                                                                                                                                             |
| `XDG_STATE_HOME`     | `$HOME/.local/state`   | Файлы состояния приложений. В отличии от `XDG_DATA_HOME`, сюда должны попадать данные, специфичные для **текущей** машины. Аналог `/var/lib`                                                                                                                 |
| `XDG_CACHE_HOME`     | `$HOME/.cache`         | Кеш                                                                                                                                                                                                                                                          |
| `XDG_RUNTIME_DIR`    | `/run/user/$UID`       | Сессионные и временные файлы. Сокеты, named pipes, данные буфера обмена, файлы, существующие только пока какое-то приложение работает. Можно удалять после перезагрузки. Задается в pam_systemd или elogind (system-less дистры) в момент входа пользователя |

В ArchLinux и ArtixLinux переменные окружения кроме XDG_RUNTIME_DIR не задаются для пользователя (если только это не делает Display Manager/Desktop Environment). Так как в данном гайде мы будем использовать тайловый оконный менеджер и полностью сами напишем скрипты инициализации окружения рабочего стола, то и недостающие переменные окружения мы должны задать сами.

Создайте эти директории самостоятельно, если они еще не существуют:
```bash
mkdir -p ~/.cache
mkdir -p ~/.config
mkdir -p ~/.local/share
mkdir -p ~/.local/state
```

Чтобы не хранить конфигурационные файлы zsh в домашней директории, необходимо переопределить переменную `ZDOTDIR`. Переопределять ее нужно на самом раннем этапе запуска zsh. Из документации zsh:

> STARTUP/SHUTDOWN FILES
> Commands are first read from /etc/zsh/zshenv; this cannot be overridden. 

Добавьте в файл `/etc/zsh/zshenv` следующую строку (если файл не существует, создайте его): 
```bash
export ZDOTDIR="${HOME}/.config/zsh"
```

Обратите внимание - когда пишете текстовые файлы, старайтесь всегда заканчивать такой файл пустой строкой, согласно [Open Group Base Specifications](https://pubs.opengroup.org/onlinepubs/9799919799/):

> Text file:
 >A file that contains characters organized into zero or more lines.

> Line
> A sequence of zero or more non-`<newline>` characters plus a terminating newline character.

Помните предыдущую статью про dotfiles? Давайте начнем сразу наполнять наш dotfiles репозиторий! Перейдите в `~/dotfiles/` и создайте директорию `zsh/.config/zsh`.  В ней 2 пустых файла `.zprofile` и `.zshrc`. Затем, всё еще находясь в `~/dotfiles/`, выполните команду
```bash
stow zsh
```

Если вы всё сделали правильно, то вывод команды `readlink ~/.config/zsh` должен показать следующее (при условии что вы находитесь в `~/dotfiles`):
```bash
../dotfiles/zsh/.config/zsh
```

**ВАЖНО!** Убедитесь, что директория `~/.config/zsh` действительно является симлинком, а не настоящей директорией. Иначе вам придётся каждый раз создавать файл в dotfiles, и запускать stow. Если данная директория является симлинком, то создавая файлы в ней, вы на самом деле сразу создаете файлы в dotfiles, и это удобнее.

в `~/dotfiles/.gitignore` добавьте:
```
zsh/.config/zsh/.zcompdump
zsh/.config/zsh/aliases-nogit.zsh
zsh/.config/zsh/plugins.zsh
```

Также, создайте директорию для хранения истории zsh:
```bash
mkdir -p ~/.local/state/zsh
```

Теперь, создайте файл `~/.config/zsh/.zprofile` и заполните его так (можете поменять на свой вкус):
```bash
# Зададим XDG Base Directories
export XDG_CONFIG_HOME="${HOME}/.config"
export XDG_DATA_HOME="${HOME}/.local/share"
export XDG_STATE_HOME="${HOME}/.local/state"
export XDG_CACHE_HOME="${HOME}/.cache"

 # если вы хотите хранить какие-то скрипты и бинари в домашней директории. Скрипты мы точно будем хранить
export PATH="${PATH}:${HOME}/.local/scripts:${HOME}/.local/bin"
# Редактор текста по умолчанию, можете поменять
export EDITOR=nvim
# Это не обязательно, но если вы хотите чтобы язык приложений вашего пользователя отличался от системы - тогда нужно указать
export LANG=en_US.UTF-8
# Ограничение размера файла истории команд, подставьте своё значение
export SAVEHIST=1000
# По умолчанию zsh хранит историю в ~, нужно это изменить
export HISTFILE="${XDG_STATE_HOME}/zsh/history"
```

После изменения zprofile нужно перелогиниться в систему для применения изменений.

На заметку: в процессе использования системы, у вас, возможно,  в `${HOME}` будут появляться`.скрытые` файлы, создаваемые различными приложениями. Чтобы поддерживать домашний каталог чистым, и хранить конфиги и данные приложений в XDG base dirs, рекомендую скрипт https://github.com/b3nj5m1n/xdg-ninja. Так же, советую почитать короткую статью [Use the XDG Base Directory Specification](https://xdgbasedirectoryspecification.com).

# Zsh

Теперь, приступим к настройке zsh. Вы можете объявить свои алиасы, функции и команды настройки внутри .zshrc. Однако, так как .zshrc представляет из себя обычный шелл-скрипт, вы можете из него ссылаться на другие файлы. Например:

Создайте файл `~/.config/zsh/.zshrc` и заполните его следующим образом:
```bash
zsh_config_dir="${ZDOTDIR:-${XDG_CONFIG_HOME}/zsh}"

if [ -e "${zsh_config_dir}/aliases.zsh" ]; then
  . "${zsh_config_dir}/aliases.zsh"
fi
if [ -e "${zsh_config_dir}/aliases-nogit.zsh" ]; then
  . "${zsh_config_dir}/aliases-nogit.zsh"
fi
```

Файл `aliases-nogit.zsh` в dotfiles класть не нужно, это как раз сделано на случай, если у вас есть алиасы, которыми вы не хотите делиться, например, устройство не личное, а корпоративное.

Теперь вы можете объявить алиасы в `~/.config/zsh/aliases.zsh`, они появятся при перезапуске терминала. Лично у меня вот такой набор:

```bash
# интерактивное меню установки пакетов для pacman
alias pacstore='pacman -Slq | fzf --multi --preview "pacman -Si {1}" | xargs -ro doas pacman -S'
alias pacin='doas pacman -S'
alias pacrem='doas pacman -Rns'
# удаление ненужных зависимостей
alias pacrmdeps='doas pacman -Rns $(pacman -Qdtq)'
alias pacupg='doas pacman -Syu'

alias aurstore='yay -Salq | fzf --multi --preview "yay -Sai {1}" | xargs -ro yay -S'
alias yain='yay -S'
alias yaupg='yay -Sau'

alias df='df -h -x tmpfs -x devtmpfs -x efivarfs'
alias free='free -h'

alias e=$EDITOR
alias g='gitui'
# найти, в каком коммите файл был удалён
alias git-find-deleted-paths='git log --diff-filter=D --summary | grep delete | grep'
alias trr='transmission-remote'

which kubecolor 1>/dev/null 2>/dev/null && alias kubectl='kubecolor' && compdef kubecolor=kubectl
alias hl='highlight --style nord'
```

# Antidote

Zsh можно кастомизировать не только алиасами. Возможно, вы уже слышали про [Oh My Zsh](https://ohmyz.sh/). Однако, у этого проекта выполняется много кода при инициализации, и это будет замедлять каждую загрузку вашего шелла (т.е. каждое открытие терминала). Кроме того, существует потребность устанавливать плагины не из репозитория omz, а других. Ранее существовал менеджер плагинов Anitgen, написанный на zsh, но он также не отличался по производительности. Затем появился Anitbody, написанный на go, чтобы решить проблему медленной инициализации. Но проект был заброшен, т.к. появились другие менеджеры плагинов, которые были еще быстрее. Проблема в том, что у antibody были фичи, которые понравились zsh-сообществу, и которых не было в других менеджерах. Поэтому и появился [antidote](https://antidote.sh/), который написан на zsh, решает многие проблемы медленной инициализации, а так же генерирует файл для статической загрузки плагинов, что сильно упрощает логику и количество кода, выполняемого при старте шелла.

Установка делается простым клонированием репозитория:

```bash
git clone --depth=1 https://github.com/mattmc3/antidote.git "${XDG_DATA_DIR}/antidote"
```

Теперь создадим файл со списком плагинов. Синтаксис файла следующий:

```bash
githubusername/githubrepo option:value
```

Список опций можно посмотреть [тут](https://antidote.sh/options)

Итак, создайте файл `~/.config/zsh/plugins.txt`. Мой рекомендуемый список плагинов:

```bash
# Т.к. мы используем некоторые плагины omz, то нужно использовать плагин use-omz от разработчика antidote. Это позволит и использовать OMZ,
# И избежать долгой инициализации
getantidote/use-omz
# загружаем библиотеки omz
ohmyzsh/ohmyzsh path:lib
# Тема prompt'а. fox есть в omz, но там вместо символа @ используется иконка хиппи, которая не на всех моноширных скриптах хорошо выглядит
# Поэтому использую форк, с замененной на @иконкой
Senderman/fox-theme-fixed
# Автодополнения для adb. Например, adb pull/push и по tab можно имена файлов с телефона вставлять. kind:fpath т.к. плагин не любит чтобы его сорсили напрямую
ohmyzsh/ohmyzsh path:plugins/adb kind:fpath
# название говорит само за себя
ohmyzsh/ohmyzsh path:plugins/colored-man-pages
# добавляет команду "x" для распаковки любых архивов, чтобы не вспоминать команду для конкретного типа архива. Требует установленных zip/tar и т.д.
ohmyzsh/ohmyzsh path:plugins/extract
# По хоткею ctrl+O текущая введёная команда скопируется в буфер обмена
ohmyzsh/ohmyzsh path:plugins/copybuffer
# При вводе cd <TAB>, позволяет выбрать необходимую директорию с помощью fzf
ohmyzsh/ohmyzsh path:plugins/zsh-interactive-cd
# Очень удобная навигация по директориям с помощью CTRL+SHIFT+<Left/Right>. Подробнее - https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/dircycle
ohmyzsh/ohmyzsh path:plugins/dircycle
# Автодополнения для git
ohmyzsh/ohmyzsh path:plugins/gitfast
# Предотвращает выполнение команд сразу после вставки без подтверждения юзера. Некоторые "злые" веб-сайты такое делают. must have
ohmyzsh/ohmyzsh path:plugins/safe-paste

# куча автодополнений для всякого
zsh-users/zsh-completions
# При вводе команд, после курсора дописывает серым цветом команды из истории, на стрелку вправо - подставляет
zsh-users/zsh-autosuggestions
# Поиск по истории как в fish - вводим часть команды, затем стрелками вверх/вниз дополняем из истории оставшующся часть
zsh-users/zsh-history-substring-search

# Если вы написали команду, на которую у вас есть алиас - плагин вам об этом расскажет, чтобы вы приучались юзать алиасы вместо полных команд
djui/alias-tips
# Подставляет/убирает doas в начало команды при двойном нажатии ESC. Если команда не введена - добавит doas к последней команде из истории
Senderman/doas-zsh-plugin
# То же самое, но для sudo
# ohmyzsh/ohmyzsh path:plugins/sudo

# Добавляет команду diff-so-fancy, а еще команду git dsf, для использования как diff. Выглядит удобнее
zdharma-continuum/zsh-diff-so-fancy
# Подсветка синтаксиса при вводе команд
zdharma-continuum/fast-syntax-highlighting
```

Чтобы почитать инфо о каком-либо плагине выше, просто подставьте его имя в `https://github.com/сюда`

Далее, добавьте в `~/.config/zsh/.zshrc` следующие строки:

```bash
# запишем в переменные пути к файлам
zsh_plugins="${zsh_config_dir}/plugins.zsh"
zsh_plugins_src="${zsh_config_dir}/plugins.txt"

# данная функция из ~/.zsh_plugins.txt генерирует файл статической инициализации ~/.zsh_plugins.zsh который можно будет сорсить
regen_plugins(){
    antidote bundle < $zsh_plugins_src > $zsh_plugins
    echo "Antidote plugins file was updated"
}

# инициализируем antidote
. ${XDG_DATA_DIR:-~/.local/share}/antidote/antidote.zsh
# если файла ~/.zsh_plugins.zsh нет, генерируем его
[ ! -e $zsh_plugins_src ] && regen_plugins
# если ~/.zsh_plugins.txt новее чем ~/.zsh_plugins.zsh, значит нужно заново его сгенерировать чтобы применить изменения
[ $zsh_plugins_src -nt $zsh_plugins ] && regen_plugins

# отключаем автообновления omz. Обновляться мы будем через antidote
zstyle ':omz:update' mode disabled

# сорсим файл статической инициализации
. $zsh_plugins
```

Перезапускаем терминал. Antidote скачает всё необходимое, и вы получите очень удобный shell, к которому вам теперь придётся привыкнуть. Не забывайте периодически обновляться командой `antidote update`.

# Fzf

Fzf это проект для fuzzy-поиска по данным. Например, по файлам или по истории команд. Ранее мы подключили плагин zsh-interactive-cd, который будет запускать fzf каждый раз, когда вы нажимаете tab после cd. Но это еще не всё.

Добавьте в `~/.config/zsh/.zshrc` и перезапустите терминал:

```bash
if [ -d /usr/share/fzf ]; then
. /usr/share/fzf/key-bindings.zsh
. /usr/share/fzf/completion.zsh
fi
```

Теперь у вас появились следующие хоткеи:

- CTRL+T - подставить после текущей позиции курсора файл из рекурсивного поиска по текущей директории
- CTRL+R - подставить команду из поиска по истории
- ALT+C - перейти в директорию из рекурсивного поиска по текущей директории

Это еще не всё. Помните мы выше добавляли алиас

```bash
alias pacstore='pacman -Slq | fzf --multi --preview "pacman -Si {1}" | xargs -ro doas pacman -S'
```

Так вот, данный алиас позволит поискать по списку пакетов (pacman -Sql), и в режиме превью будет отображать информацию о пакете, на который наведен курсор. При подтверждении выбора, будет вызвана команда `doas pacman -S pkgname`. Получаем такой вот консольный магазин приложений. Сценариев использования у fzf много, так что экспериментируйте.

# Compinit

Ранее мы ставили несколько плагинов для автодополнения, но чтобы они работали, нужно инициализировать систему автодополнения (Zsh Completion System).

Добавьте **в конец (это очень важно!!!)** `~/.config/zsh/.zshrc`:

```bash
autoload -Uz compinit
compinit
```

# Zoxide

Перемещаться по директориям после установки плагина `zsh-users/zsh-autosuggestions` стало гораздо удобнее, так как теперь вы видите сразу серым цветом путь к предлагаемой директории после cd, и можете на стрелку вправо подтвердить дополнение, но можно еще лучше. Существует программа zoxide, которая представляет из себя очень умную замену `cd`.

Добавьте в конец (**после**  compinit) `~/.config/zsh/.zshrc`:

```bash
eval "$(zoxide init zsh)"
```

Теперь вам нужно привыкнуть использовать команду `z` вместо `cd`. Сценарий использования:

```bash
z ~/some/directory/deep/inside/home/dir/mycoolproject
# работает как обычная cd
z ~
# перейдет в ~/some/directory/deep/inside/home/dir/mycoolproject. Если директорий mycoolproject запомнено несколько, перейдет в самую часто используемую
z mycoolproject
# интерактивное автодополнение.
z mycool<SPACE><TAB>
```

Редактировать БД сохранённых директорий можно внутри интерактивной утилиты, вызываемой через `zoxide edit`. Там же можно изменить и score использования команд, если вы замечаете, что zoxide принимает "неподходящие" решения при выборе среди одноимённых директорий.

Мой актуальный конфиг zsh доступен тут: https://github.com/Senderman/dotfiles/tree/master/zsh
